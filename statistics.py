#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2020 Gerasimov Alexander <samik.mechanic@gmail.com>
#
# Class and methods representing guild war statistics collection
#

import os, datetime, time, copy, pickle, json
from logger import get_logger

import common
from icons import *
import helpers as hlp

log = get_logger("bot." + __name__)

class Jsonable(object):
    """
    Base class to make JSON serialize nested statistic objects
    """
    def __iter__(self):
        for attr, value in self.__dict__.iteritems():
            if isinstance(value, datetime.datetime):
                iso = value.isoformat()
                yield attr, iso
            elif(hasattr(value, '__iter__')):
                if(hasattr(value, 'pop')):
                    a = []
                    for subval in value:
                        if(hasattr(subval, '__iter__')):
                            a.append(dict(subval))
                        else:
                            a.append(subval)
                    yield attr, a
                else:
                    yield attr, dict(value)
            else:
                yield attr, value

class StatsEncoder(json.JSONEncoder):
    """
    Encoder for statistic objects for JSON
    """
    def default(self, obj):
        if isinstance(obj, User) or \
           isinstance(obj, Score) or \
           isinstance(obj, StatRecord):
            return repr(obj)
        elif isinstance(obj, Statistic):
            return obj.__dict__
        else:
            return json.JSONEncoder.default(self, obj)

def GetBestListText(best_list, key="battles"):
    """
    Support function getting the best users list in text view.
    Prefixes user records with medals, suffixes with personal count
    """
    MEDALS = ["ü•á", "ü•à", "ü•â", "4Ô∏è‚É£", "5Ô∏è‚É£", "6Ô∏è‚É£", "7Ô∏è‚É£", "8Ô∏è‚É£", "9Ô∏è‚É£", "üîü"]
    text = ""
    for i in range(0, len(best_list)):
        user  = best_list[i]["user"].GetData()
        score = best_list[i]["score"].GetData()
        text += MEDALS[i] + " [%s" % user["name"]
        if user["username"]:
            text += " (%s)" % user["username"]
        text += "](tg://user?id=%d) _(%d)_\n" % (user["id"], score[key])
    return text if text != "" else "_–Ω–µ—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π_"


@common.bot.message_handler(commands=['statbackup'])
def command_stat_backup(m):
    """
    Backup whole current statistic into pickle and json-readable files.
    Send files to user
    """
    user = [m.from_user.id, m.from_user.username, m.from_user.first_name]
    log.debug("User %d (%s %s) is requested statistics backup" % (*user,))
    try:
        if not hlp.IsInPrivateChat(m):
            common.bot.delete_message(m.chat.id, m.message_id)
            hlp.SendHelpWrongChat(m.from_user.id, "/statbackup", "—Å–æ–∑–¥–∞—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏", True)
            return
    except: # case if called from Statistic backup timeout. Could be ignored
        pass
    if not hlp.IsUserAdmin(m):
        hlp.SendHelpNonAdmin(m)
        return
    FILE_PREFIX = "GWBotStatistic"
    common.bot.send_message(m.from_user.id, "üì• –°–æ—Ö—Ä–∞–Ω—è—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É...")
    try:
        # dump pickle Statistic object
        with open(FILE_PREFIX+'.BAK', 'wb') as backup:
            pickle.dump(common.statistics, backup, pickle.HIGHEST_PROTOCOL)
            backup.close()
        # dump json Statistic object
        with open(FILE_PREFIX+'.txt', 'w') as backup_json:
            json.dump(common.statistics, backup_json, separators=(',', ': '), cls=StatsEncoder, indent=4, ensure_ascii=False)
            backup_json.close()
        # send pickle
        common.bot.send_chat_action(m.from_user.id, "upload_document")
        with open(FILE_PREFIX+'.BAK', 'rb') as backup:
            common.bot.send_document(m.from_user.id, backup, caption="–§–∞–π–ª-–æ–±—ä–µ–∫—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏").wait()
            backup.close()
        aws_stat_backup(FILE_PREFIX+'.BAK', burst=True)
        os.remove(FILE_PREFIX+'.BAK')
        # send json
        common.bot.send_chat_action(m.from_user.id, "upload_document")
        with open(FILE_PREFIX+'.txt', 'r') as backup_json:
            common.bot.send_document(m.from_user.id, backup_json, caption="JSON-–æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏").wait()
            backup_json.close()
        os.remove(FILE_PREFIX+'.txt')
    except Exception as err:
        log.error("Backup statistics failed: ", str(err))
        common.bot.send_message(m.from_user.id, ICON_CANCEL+" –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏!")


def aws_stat_backup(filename="GWBotStatistic.BAK", burst=False):
    """
    Backup whole current statistic into pickle file.
    Upload to AWS
    @param burst Do not save backup to file
    """
    log.debug("AWS Statistic backup started")
    # common.bot.send_message(int(common.ROOT_ADMIN[0]), "üåê –°–æ—Ö—Ä–∞–Ω—è—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É (AWS)...")
    # if burst-upload requested (no additional file backup)
    if not burst:
        with open(filename, 'wb') as backup:
            pickle.dump(common.statistics, backup, pickle.HIGHEST_PROTOCOL)
            backup.close()
    # upload file
    if hlp.AWSUploadFile(filename):
        log.debug("Statistics has been successfully uploaded to AWS cloud.")
        # common.bot.send_message(int(common.ROOT_ADMIN[0]), ICON_CHECK+" –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!")
    else:
        log.error("Statistics AWS upload failed.")
        common.bot.send_message(int(common.ROOT_ADMIN[0]), ICON_CANCEL+" –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏!")


@common.bot.message_handler(commands=['statrestore'])
def command_stat_restore(m):
    """
    Restore whole current statistic from pickle file (command help part).
    """
    user = [m.from_user.id, m.from_user.username, m.from_user.first_name]
    log.debug("User %d (%s %s) is requested statistics restore" % (*user,))
    if not hlp.IsInPrivateChat(m):
        common.bot.delete_message(m.chat.id, m.message_id)
        hlp.SendHelpWrongChat(m.from_user.id, "/statrestore", "–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–∑ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏", True)
        return
    if not hlp.IsUserAdmin(m):
        hlp.SendHelpNonAdmin(m)
        return
    common.bot.send_message(m.from_user.id,
                            "üóÑ –ß—Ç–æ–±—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É, –ø—Ä–∏—à–ª–∏—Ç–µ —Ñ–∞–π–ª —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ _.BAK_",
                            parse_mode="markdown")


def aws_stat_restore(filename="GWBotStatistic.BAK", force=True):
    """
    Restore whole current statistic from pickle file (download from AWS).
    @param force Remove old local backup
    """
    log.debug("AWS Statistic restore started")
    # common.bot.send_message(int(common.ROOT_ADMIN[0]), "üåê –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É (AWS)...")
    try:
        # remove old statistics backup if forced update
        if force:
            if os.path.isfile(filename):
                os.remove(filename)
        # download backup
        filepath = hlp.AWSDownloadFile(filename)
        if filepath == None:
            raise Exception("Statistics AWS download failed.")
        log.debug("Statistics has been successfully downloaded from AWS cloud.")
        # unwrap and set object
        with open(filepath, 'rb') as f:
            common.statistics = pickle.load(f)
            f.close()
        # common.bot.send_message(int(common.ROOT_ADMIN[0]), ICON_CHECK+" –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —É—Å–ø–µ—à–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!")
        log.debug("Restoring statistics successful (AWS)")
    except Exception as err:
        log.error("Restoring statistics failed (AWS): %s", str(err))
        common.bot.send_message(int(common.ROOT_ADMIN[0]), ICON_CANCEL+" –û—à–∏–±–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏!")


@common.bot.message_handler(func=lambda message: os.path.splitext(message.document.file_name)[1].lower() == ".bak" if message.document else False,
                            content_types=['document'])
def file_stat_restore(m):
    """
    Restore whole current statistic from pickle file.
    """
    # print(m)
    user = [m.from_user.id, m.from_user.username, m.from_user.first_name]
    log.debug("User %d (%s %s) is trying to restore statistics" % (*user,))
    FILENAME = "stats.BAK"
    common.bot.send_message(m.from_user.id, "üì§ –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É...")
    try:
        backup = common.bot.download_file(common.bot.get_file(m.document.file_id).wait().file_path).wait()
        with open(FILENAME, 'wb') as f:
            f.write(backup)
            f.close()
        with open(FILENAME, 'rb') as f:
            common.statistics = pickle.load(f)
            f.close()
        os.remove(FILENAME)
        common.bot.send_message(m.from_user.id, ICON_CHECK+" –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —É—Å–ø–µ—à–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!")
        log.debug("Restoring statistics successful")
    except Exception as err:
        log.error("Restoring statistics failed: %s", str(err))
        common.bot.send_message(m.from_user.id, ICON_CANCEL+" –û—à–∏–±–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏!")

@common.bot.message_handler(commands=['best'])
def command_best(m):
    """
    Call to show guild statistics (war chat command)
    """
    # print("command_best")
    # print(m)
    user = [m.from_user.id, m.from_user.username, m.from_user.first_name]
    log.debug("User %d (%s %s) is trying to request guild stats" % (*user,))
    if hlp.IsInPrivateChat(m):
        hlp.SendHelpWrongChat(m.from_user.id, "/best", "–ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª—É—á—à–∏—Ö –∑–∞ –í–ì", False)
        return
    common.bot.delete_message(m.chat.id, m.message_id)
    if not hlp.IsGWEndingTime():
        common.bot.send_message(user[0], "–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –≤ –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –í–ì!")
        log.error("Failed: wrong time")
        return
    
    if not common.statistics.is_posted:
        if common.warchat_id:
            DELAY = 5
            total_stats   = common.statistics.GetTotalValues().GetData()
            total_battles = common.statistics.GetBattlesCount()
            # starting message
            init_stats_msg = common.bot.send_message(common.warchat_id,
                "üìà *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤–æ–π–Ω—ã –≥–∏–ª—å–¥–∏–π:*\n\n" + \
                ICON_SWORDS+" *–ü—Ä–æ–≤–µ–¥–µ–Ω–æ –±–æ–µ–≤:* " + str(total_battles) + " _(" + str(total_stats["battles"]) + " —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤)_\n" + \
                ICON_ARS+" *–°–æ–±—Ä–∞–Ω–æ –±–æ–µ–≤—ã—Ö –¥–æ—Å–ø–µ—Ö–æ–≤:* " + str(total_stats["arsenal"]) + "\n" + \
                ICON_STAR+" *–°–Ω—è—Ç–æ –≤—Ä–∞–∂–µ—Å–∫–∏—Ö –∑–≤–µ–∑–¥:* " + str(total_stats["stars"]) + "\n",
                parse_mode="markdown").wait()
            common.bot.send_chat_action(common.warchat_id, "typing")
            time.sleep(DELAY)
            common.bot.send_message(common.warchat_id,
                                    "üèÜ *–°–ø–∏—Å–∫–∏ –ª—É—á—à–∏—Ö –∏–≥—Ä–æ–∫–æ–≤:*",
                                    parse_mode="markdown").wait()
            common.bot.send_chat_action(common.warchat_id, "typing")
            time.sleep(DELAY)
            # best players
            best_actives_header   = ICON_SWORDS+" *–õ—É—á—à–∏–π –∞–∫—Ç–∏–≤*:\n\n"
            best_arsenal_header   = ICON_ARS+   " *–õ—É—á—à–∏–µ –∞—Ä—Å–µ–Ω–∞–ª—å—â–∏–∫–∏*:\n\n"
            best_attackers_header = ICON_STAR+  " *–õ—É—á—à–∏–µ —Ç–∞–Ω–∫–∏*:\n\n"
            WAIT_SUFFIX = "ü•Å..."
            # best active players
            text = GetBestListText(common.statistics.GetBestActives(), "battles")
            best_actives_msg = common.bot.send_message(common.warchat_id,
                                                best_actives_header + WAIT_SUFFIX,
                                                parse_mode="markdown").wait()
            common.bot.send_chat_action(common.warchat_id, "typing")
            time.sleep(DELAY)
            common.bot.edit_message_text(best_actives_header + text,
                                  chat_id=best_actives_msg.chat.id,
                                  message_id=best_actives_msg.message_id,
                                  parse_mode="markdown")
            # best arsenal players
            text = GetBestListText(common.statistics.GetBestArsenals(), "arsenal")
            best_arsenal_msg = common.bot.send_message(common.warchat_id,
                                                best_arsenal_header + WAIT_SUFFIX,
                                                parse_mode="markdown").wait()
            common.bot.send_chat_action(common.warchat_id, "typing")
            time.sleep(DELAY)
            common.bot.edit_message_text(best_arsenal_header + text,
                                  chat_id=best_arsenal_msg.chat.id,
                                  message_id=best_arsenal_msg.message_id,
                                  parse_mode="markdown")
            # best attackers
            text = GetBestListText(common.statistics.GetBestAttackers(), "stars")
            best_attackers_msg = common.bot.send_message(common.warchat_id,
                                                best_attackers_header + WAIT_SUFFIX,
                                                parse_mode="markdown").wait()
            common.bot.send_chat_action(common.warchat_id, "typing")
            time.sleep(DELAY)
            common.bot.edit_message_text(best_attackers_header + text,
                                  chat_id=best_attackers_msg.chat.id,
                                  message_id=best_attackers_msg.message_id,
                                  parse_mode="markdown")
            # ending messages
            common.bot.send_message(common.warchat_id,
                             ICON_PRAISE+" *–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π!* " + ICON_PRAISE + "\n\n" + \
                             "_–õ—É—á—à–µ–º—É –∏–≥—Ä–æ–∫—É –≤ –ª—é–±–æ–π –Ω–æ–º–∏–Ω–∞—Ü–∏–∏ –ø—Ä–∏—Å—É–∂–¥–∞–µ—Ç—Å—è üéñ –æ—Ä–¥–µ–Ω, " + \
                             "–∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤–∏–¥–µ–Ω –Ω–∞ –≤–æ–π–Ω–∞—Ö –≤ —Ç–µ—á–µ–Ω–∏–µ " + \
                             str(common.statistics.cycle_time) + " –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –≤–æ–π–Ω._",
                             parse_mode="markdown")
            common.statistics.is_posted = True
            log.info("Guild stats posted!")
        else:
            hlp.SendHelpWrongChat(m.from_user.id, "/warchat", "–∑–∞–ø–æ–º–Ω–∏—Ç—å –≤–æ–µ–Ω–Ω—ã–π —á–∞—Ç", False)
            log.error("War chat_id is not set, cannot post GW stats!")
    else:
        common.bot.send_message(user[0], "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —É–∂–µ –±—ã–ª–∞ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞!")
        log.error("Guild stats has been already posted!")

#
# Base class representing a User object
#
class User(Jsonable):
    _id      = None
    name     = None
    username = None

    def __init__(self, _id, name=None, username=None):
        self._id      = _id
        self.name     = name
        self.username = username

    def __hash__(self):
        return hash((self._id))

    def __eq__(self, other):
        return (self._id) == (other._id)

    def __ne__(self, other):
        return not(self == other)

    def __repr__(self):
        text = "User(%d, %s" % (self._id, self.name)
        if self.username:
            text += ", %s)" % self.username
        else:
            text += ")"
        return text

    def GetData(self):
        return {"id"      : self._id,
                "name"    : self.name,
                "username": self.username
                }


#
# Base class representing a war record object
#
class Score(Jsonable):
    battles = 0
    arsenal = 0
    stars   = 0

    def __init__(self, battle=0, arsenal=0, stars=0):
        self.battles = battle
        self.arsenal = arsenal
        self.stars   = stars

    def __hash__(self):
        return hash((self.battles, self.arsenal, self.stars))

    def __eq__(self, other):
        return (self.battles, self.arsenal, self.stars) == (other.battles, other.arsenal, other.stars)

    def __ne__(self, other):
        return not(self == other)

    def __sub__(self, other):
        diff = [self.battles - other.battles,
                self.arsenal - other.arsenal,
                self.stars   - other.stars]
        self.battles = diff[0] if diff[0] > 0 else 0
        self.arsenal = diff[1] if diff[1] > 0 else 0 
        self.stars   = diff[2] if diff[2] > 0 else 0
        return self

    def __repr__(self):
        return "Score(B: %d, A: %d, S: %d)" % (self.battles, self.arsenal, self.stars)

    def AddScore(self, score):
        if not isinstance(score, self.__class__):
            log.error("Trying to add score using another Score, but object type is wrong")
            return
        self.battles = self.battles + score.battles
        self.arsenal = self.arsenal + score.arsenal
        self.stars   = self.stars + score.stars

    def RemoveScore(self, score):
        if not isinstance(score, self.__class__):
            log.error("Trying to add score using another Score, but object type is wrong")
            return
        # invert score then add it
        score.battles = (-1)*score.battles
        score.arsenal = (-1)*score.arsenal
        score.stars   = (-1)*score.stars
        self.AddScore(score)

    def GetData(self):
        return {"battles": self.battles,
                "arsenal": self.arsenal,
                "stars"  : self.stars
                }

class StatRecord(Jsonable):
    date = None # datetime
    stats = {}  # {User: Score}
    battles_count = 0

    def __init__(self):
        self.date = datetime.datetime.now()
        self.stats = {}
        self.battles_count = 0

    def __sub__(self, other):
        self.battles_count -= other.battles_count
        for user1, score1 in self.stats.items():
            for user2, score2 in other.stats.items():
                if user1 == user2:
                    self.stats[user1] = self.stats[user1] - other.stats[user2]
        return self

    def __repr__(self):
        text = []
        for user, score in self.stats.items():
            text.append(repr(user) + ": " + repr(score))
        return "StatRecord[%s][B: %d](%s)" % (self.date, self.battles_count, ", ".join(text))

    def AddStat(self, user, record):
        if user not in self.stats:
            self.stats[user] = record
        else:
            self.stats[user].AddScore(record)

    def AddBattle(self):
        self.battles_count += 1

    def GetBattlesCount(self):
        return self.battles_count

    def GetDate(self):
        return self.date

    def GetStat(self):
        return self.stats

    def GetRawData(self):
        return [(user.GetData(), score.GetData()) for user, score in self.stats.items()]

    def GetBest(self, key, count):
        stats_temp = copy.deepcopy(self.stats)
        best = []
        best_temp = {"user" : User(-1),
                     "score": Score()
                     }
        for i in range(0, count):
            # init starting best user
            best_one = copy.deepcopy(best_temp)
            # find the best user
            for user, score in stats_temp.items():
                new_score = score.GetData()[key]
                if new_score >= best_one["score"].GetData()[key] and \
                   new_score != 0:
                    best_one["user"] = user
                    best_one["score"] = score
            if best_one["user"] != best_temp["user"]:
                # save it
                best.append(best_one)
                # remove from list and start over for the further places
                del stats_temp[best_one["user"]]
        return best

class Statistic(Jsonable):
    statistics  = [] # [StatRecord] of size cycle_time. lowest index is the newer stat
    nominated   = [] # [User]
    cycle_time  = 4  # in weeks
    is_posted = False
    backup_timeout = 2 # backup statistic every 3 records (send to the root admin)
    update_counter = 0 # counter of updates for backup'ing

    def __init__(self, cycle_time):
        self.cycle_time     = cycle_time
        self.statistics     = [StatRecord() for i in range(0, cycle_time)]
        self.nominated      = []
        self.is_posted      = False
        self.backup_timeout = 2
        self.update_counter = 0

    def Update(self, update):
        print("UPDATE: ", update)
        print("NONUPDATED STATS:")
        print(self.statistics)
        is_battle_update = False
        if isinstance(update, StatRecord): # unpack StatRecord to dict type
            update = update.GetStat()
        elif not isinstance(update, dict): # default update type
            log.error("Invalid update type: %s (dict or StatRecord expected)", type(update))
            return
        for user, score in update.items():
            if not isinstance(user, User) or not isinstance(score, Score):
                log.error("Invalid update item: %s:%s (need User: Score)", type(user), type(score))
                return
            self.statistics[0].AddStat(user, score)
            if score.GetData()["battles"] > 0:
                is_battle_update = True
        if is_battle_update:
            self.statistics[0].AddBattle()
        print("UPDATED STATS:")
        print(self.statistics)

    def GetTotalValues(self):
        total = Score()
        for score in self.statistics[0].GetStat().values():
            total.AddScore(score)
        return total

    def GetBattlesCount(self):
        return self.statistics[0].GetBattlesCount()

    def GetNominatedPrefix(self, user):
        # workaround User object creation if argument is simple list
        if not isinstance(user, User):
            user = User(*user,)
        if user in self.nominated:
            return "üéñ "
        return ""

    def AddNomination(self, best_record):
        if len(best_record) == 0:
            return
        if best_record[0]["user"] not in self.nominated:
            self.nominated.append(best_record[0]["user"])

    def RemoveNominations(self, stat):
        if not stat: # at the very start older stats do not exist yet
            return
        for user in stat.GetStat().keys():
            if user in self.nominated:
                self.nominated.remove(user)

    # get users that checked for battle the most
    def GetBestActives(self, count=3):
        result = self.statistics[0].GetBest("battles", count)
        self.AddNomination(result)
        return result

    # get users that checked for battle the most
    def GetBestArsenals(self, count=3):
        result = self.statistics[0].GetBest("arsenal", count)
        self.AddNomination(result)
        return result

    # get users that checked for battle the most
    def GetBestAttackers(self, count=3):
        result = self.statistics[0].GetBest("stars", count)
        self.AddNomination(result)
        return result

    def BackupIfNeed(self, msg):
        # new AWS backup
        aws_stat_backup()
        # old local backup cycle
        # if self.update_counter < self.backup_timeout:
        #     self.update_counter += 1
        # else:
        #     # pre-mutations of message to imitate root admin backup request
        #     msg.from_user.id = int(common.ROOT_ADMIN[0])
        #     msg.from_user.name = common.ROOT_ADMIN[1]
        #     command_stat_backup(msg)
        #     self.update_counter = 0


    def CycleIfNeed(self):
        """
        Statistics cyclying funcion.
        Executes cycling if checked from Friday to Sunday (next GW detected) and making sure it is not the same GW.
        """
        now = datetime.datetime.now()
        # TODO: check if 3 days threshold is enough to detect new GW (mind testing!)
        diff = now - self.statistics[0].GetDate()
        if diff.days >= 3 :# and hlp.IsGWDurationTime():
            self.do_cycle_internal()

    def do_cycle_internal(self):
        print("before cycle:")
        print(self.statistics)        
        # shift the stats records to the right
        self.statistics = self.statistics[-1:] + self.statistics[:-1]
        # eliminate oldest nominated users
        self.RemoveNominations(self.statistics[0])
        # destroy the oldest (now first)
        print("before destroy old StatRecord:")
        print(self.statistics)
        self.statistics[0] = StatRecord()
        print("after re-init newest:")
        print(self.statistics)
        self.is_posted = False
